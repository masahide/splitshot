import { Command } from "commander";
import fs from "node:fs";
import path from "node:path";
import { findLatestPlanDir } from "../core/paths.js";
import { readManifestV3 } from "../core/manifest.js";
import { runGit, GitError } from "../core/git.js";
import { runGh, GhError } from "../core/gh.js";

function resolvePlanDir(planDirOption: string | undefined): string {
    if (planDirOption) {
        const abs = path.resolve(planDirOption);
        if (!fs.existsSync(abs) || !fs.statSync(abs).isDirectory()) {
            throw new Error(`plan-dir が見つかりません: ${planDirOption}`);
        }
        return abs;
    }
    const base = path.resolve(".splitshot");
    const latest = findLatestPlanDir(base);
    if (!latest) {
        throw new Error("最新の plan-dir が見つかりません。Step3 と worktrees up を実行してください。");
    }
    return latest;
}

function toAbsolute(repoDir: string, relative: string): string {
    const abs = path.resolve(repoDir, relative);
    fs.mkdirSync(abs, { recursive: true });
    return abs;
}

export function cmdIntegrate(): Command {
    const cmd = new Command("integrate");
    cmd
        .description("worktree で作業したブランチをコミット・プッシュし、PR を作成する")
        .option("--plan-dir <dir>", "対象の plan-dir")
        .option("--base <branch>", "PR の base ブランチ", "main")
        .option("--title-prefix <text>", "コミット/PR タイトルの接頭辞", "[AI] ")
        .option("--draft", "PR を draft として作成する")
        .option("--no-open", "PR 作成後にブラウザを開かない")
        .option("--git-bin <path>", "git 実行バイナリ", process.env.FAKE_GIT_BIN ?? "git")
        .option("--gh-bin <path>", "gh 実行バイナリ", process.env.FAKE_GH_BIN ?? "gh")
        .action(async (opts: {
            planDir?: string;
            base: string;
            titlePrefix: string;
            draft?: boolean;
            open?: boolean;
            gitBin: string;
            ghBin: string;
        }) => {
            const repoDir = process.cwd();
            const record = (line: string) => {
                const target = process.env.SPLITSHOT_TEST_STDOUT_FILE;
                if (target) {
                    fs.appendFileSync(target, `${line}\n`, "utf8");
                }
                console.log(line);
            };
            const planDir = resolvePlanDir(opts.planDir);
            const manifestPath = path.join(planDir, "manifest.v3.json");
            const manifest = readManifestV3(manifestPath);

            if (!manifest.worktrees?.branches?.length) {
                throw new Error("manifest.worktrees.branches が空です。`splitshot worktrees up` を先に実行してください。");
            }

            const gitBin = opts.gitBin;
            const ghBin = opts.ghBin;
            const titlePrefix = opts.titlePrefix ?? "[AI] ";
            const branches = manifest.worktrees.branches;
            const processed: string[] = [];

            for (const entry of branches) {
                const worktreeAbs = toAbsolute(repoDir, entry.dir);
                const commitTitle = `${titlePrefix}${entry.branch}`;

                await runGit({
                    bin: gitBin,
                    args: ["-C", worktreeAbs, "add", "-A"],
                    cwd: repoDir,
                    env: process.env,
                });

                try {
                    await runGit({
                        bin: gitBin,
                        args: ["-C", worktreeAbs, "commit", "-m", commitTitle],
                        cwd: repoDir,
                        env: process.env,
                    });
                } catch (err) {
                    if (err instanceof GitError) {
                        const text = `${err.stdout}\n${err.stderr}`.toLowerCase();
                        if (text.includes("nothing to commit")) {
                            console.warn(`${entry.branch}: コミット対象がありませんでした (nothing to commit)`);
                        } else {
                            throw err;
                        }
                    } else {
                        throw err;
                    }
                }

                await runGit({
                    bin: gitBin,
                    args: ["-C", worktreeAbs, "push", "-u", "origin", entry.branch],
                    cwd: repoDir,
                    env: process.env,
                });
                processed.push(entry.branch);
            }

            const headBranch = processed[0];
            if (!headBranch) {
                console.log("コミット対象のブランチが見つからなかったため PR 作成をスキップしました。");
                return;
            }

            const prTitle = `${titlePrefix}${headBranch}`;
            const prBody = [
                "## Summary",
                "- Generated by splitshot integrate",
                "",
                "## Branches",
                ...processed.map((branch) => `- ${branch}`),
            ].join("\n");

            const ghArgs = [
                "pr",
                "create",
                "--base",
                opts.base,
                "--head",
                headBranch,
                "--title",
                prTitle,
                "--body",
                prBody,
            ];
            if (opts.draft) {
                ghArgs.push("--draft");
            }
            if (opts.open === false) {
                ghArgs.push("--no-open");
            }

            try {
                const ghResult = await runGh({
                    bin: ghBin,
                    args: ghArgs,
                    cwd: repoDir,
                    env: process.env,
                });
                const message = ghResult.stdout.trim();
                const output = message.length > 0 ? message : `gh pr create --base ${opts.base} --head ${headBranch}`;
                record(output);
                record(`gh pr create --base ${opts.base} --head ${headBranch}`);
            } catch (err) {
                if (err instanceof GhError) {
                    const instructions = [
                        "gh CLI の実行に失敗したため、手動手順を表示します。",
                        `git push origin ${headBranch}`,
                        `gh pr create --base ${opts.base} --head ${headBranch}`,
                    ];
                    instructions.forEach(record);
                } else {
                    throw err;
                }
            }
        });

    return cmd;
}
