=== BEGIN FILE: docs/spec.md ===
# SplitShot 仕様書（2モード版：プラン / 並列実行）

## 概要

SplitShot は、Codex を用いてソフトウェア開発タスクを **計画（プラン）**し、生成された **チェックリスト（Markdown）** を元に **並列で実行**する CLI ツールです。
ユーザー操作は原則 **2コマンド**のみで完了します。

1. **プランフェーズ**: 目的と並列数を入力すると、並列数ぶんの **TODO チェックリスト（Markdown）** と **マニフェスト** が生成されます。
2. **並列実行フェーズ**: 生成されたチェックリストを単位に Codex を **並列実行**し、状態・ログを収集します（`codex exec --json`）。

---

## ゴール / 非ゴール

* **ゴール**

  * 初見でも迷わない、最小オプションの 2 ステップ運用
  * チェックリスト（人間可読）を中心とした成果物で状況把握が容易
  * 実行の可観測性（状態イベント、標準出力/エラー、JSONL 取り込み）

* **非ゴール**

  * きめ細かい DAG リソース管理（初期版はワーカー内順序保証に限定）
  * Git worktree 作成の実行（コマンド生成は今後の拡張範囲）

---

## 用語

* **プランディレクトリ（plan-dir）**: 1 回のプラン生成で作られるディレクトリ。チェックリストやマニフェスト、実行ログが格納されます。
  既定パス: `./.splitshot/plan-<timestamp>/`
* **チェックリスト**: 各ワーカーが実施する TODO をまとめた Markdown。`checklists/worker-01.md` など。
* **マニフェスト**: 実行時に参照する JSON。チェックリスト一覧やメタ情報を含みます。
* **ラン**: 1 回の並列実行。`<plan-dir>/.runs/<timestamp>/` にイベントログを保存。

---

## CLI

### 1) プランフェーズ

```
splitshot plan \
  --objective <file|text> \
  --workers <N> \
  [--out <dir>] \
  [--codex-bin <path>] \
  [--timeout <ms>]
```

* **必須**

  * `--objective`: 目的文（ファイルパスまたはテキスト）。
  * `--workers`: 並列数（= 生成するチェックリスト数）。
* **任意**

  * `--out`: 出力先ディレクトリ（既定: `./.splitshot/plan-<timestamp>/`）
  * `--codex-bin`: Codex バイナリ（既定: `codex`）
  * `--timeout`: Codex 実行タイムアウト（既定: 120000ms）

**処理内容**

* Codex の `--output-schema` / `--json` 対応を検出（スキップ可）。
* `src/templates/plan.schema.json`（draft 2020-12）に合致する **Plan JSON** を取得・検証。
* Plan のタスクをトポロジー順に **N 本のワーカーストリームへ分配**（ラウンドロビン）。
* 各ストリームごとに **チェックリスト（Markdown）** を生成。
* **マニフェスト（JSON）** を生成。

**出力（plan-dir 配下）**

```
.splitshot/plan-<ts>/
  plan.json                 # Codex から取得・検証済みの計画（内部形式）
  manifest.json             # run が参照するエントリポイント
  plan.prompt.txt           # Codex へ渡したプロンプトのコピー
  checklists/
    worker-01.md
    worker-02.md
    ...
```

**チェックリストの構成（例）**

```md
# Worker 01 — TODO Checklist

## Context
<objective の要約または抜粋>

## Tasks
- [ ] t1: Bootstrap runner
  - Summary: ...
  - Acceptance: ...
- [ ] t3: Tail command
  - Summary: ...
  - Acceptance: ...

## Notes
- 出力は JSONL も含めて行単位でわかるように
- 重要メトリクスは最後に箇条書きで報告
```

**マニフェストの構成（例）**

```json
{
  "version": 1,
  "objective": "<string>",
  "createdAt": "2025-09-27T11:22:33Z",
  "workers": [
    { "id": "w01", "checklist": "checklists/worker-01.md" },
    { "id": "w02", "checklist": "checklists/worker-02.md" }
  ]
}
```

---

### 2) 並列実行フェーズ

```
splitshot run \
  [--plan-dir <dir>] \
  [--codex-bin <path>] \
  [--max-parallel <N>] \
  [--auto-isolate]
```

* **既定**

  * `--plan-dir`: 最新の `./.splitshot/plan-*/` を自動選択
  * `--codex-bin`: `codex`
  * `--max-parallel`: チェックリスト数（`manifest.workers.length`）
  * `--auto-isolate`: 有効（同一 `CODEX_HOME` 検知時に `-iso-<uniq>` 付与）

**処理内容**

* `manifest.json` を読み、`workers[]` を対象に並列実行。
* 各ワーカーについて:

  * `checklists/worker-XX.md` をプロンプトに整形し、
    `codex exec --json -- "<prompt>"` を起動。
  * 実行環境:

    * `cwd = <plan-dir>`
    * `env.CODEX_HOME = <plan-dir>/.homes/<workerId>`（競合時は `-iso-<uniq>` 付与）
    * 追加環境変数:

      * `SPLITSHOT_RUN_ID=<workerId>`
      * `SPLITSHOT_CHECKLIST_FILE=<abs path to md>`
  * ログ収集:

    * `stdout` / `stderr` を行単位で取り込み
    * `$CODEX_HOME/sessions/**/rollout-*.jsonl` を 200ms 間隔で追従（後から出現するファイルも取り込み）
  * 状態管理:

    * `state:start` / `state:exit(code)` を記録
    * 同一ワーカー内で致命的失敗が発生した場合、後続項目を `state:blocked` で記録（将来の詳細化対象）

**出力（plan-dir 配下）**

```
.splitshot/plan-<ts>/
  .runs/
    latest.json              # { "runDir": "<abs path>" }
    <run-ts>/
      events.ndjson
      run.meta.json          # { workers, maxParallel, codexHomes }
  .homes/
    w01/ ... (CODEX_HOME)
    w02/ ...
```

**イベント（NDJSON）形式**

```json
{"t": 1738020000000, "type": "state",  "runId": "w01", "data": {"phase": "start"}}
{"t": 1738020000100, "type": "stdout", "runId": "w01", "data": {"line": "..."}} 
{"t": 1738020000200, "type": "jsonl",  "runId": "w01", "data": {"line": "{\"step\":1}"}} 
{"t": 1738020000300, "type": "state",  "runId": "w01", "data": {"phase": "exit", "code": 0}}
{"t": 1738020000400, "type": "state",  "runId": "w02", "data": {"phase": "blocked", "reason": "dependency_failed"}}
```

**終了コード**

* すべて成功で `0`
* いずれか失敗で `1`

---

### 3) ログ閲覧

```
splitshot tail \
  [--plan-dir <dir>] \
  [--run <id|all>] \
  [--type stdout,stderr,jsonl,state] \
  [--duration <ms>]
```

* 既定で `--plan-dir` の latest run を参照
* `--duration` 指定時は追尾、それ以外は現状出力のみ

---

## 既定値と挙動の要点

* **2コマンド運用**

  * `splitshot plan --objective <...> --workers <N>`
  * `splitshot run`
    これだけで、直近の plan-dir を用いて並列実行まで通ります。
* **成果物の一元化**
  すべて **plan-dir** に集約。中間成果物（チェックリスト、マニフェスト）と、実行結果（events / meta）が一箇所に揃います。
* **Codex 実行**

  * 既定は `codex exec --json` を直接起動。
  * `.js` ランナーを渡す場合は `--codex-bin <path/to/script.js>` を指定すると Node 経由で起動します。
* **CODEX_HOME 衝突**

  * 同一パスが同時使用される場合は起動前に検知。
  * `--auto-isolate` 有効時は自動で `-iso-<uniq>` をサフィックス付与。

---

## データ仕様（抜粋）

* **Plan JSON**: `src/templates/plan.schema.json`（draft 2020-12）
* **Manifest JSON**

  ```ts
  type Manifest = {
    version: 1;
    objective: string;
    createdAt: string; // ISO8601
    workers: { id: string; checklist: string }[];
  }
  ```
* **イベント NDJSON**

  ```ts
  type StateEvent =
    | { type:"state"; runId:string; t:number; data:{ phase:"start" } }
    | { type:"state"; runId:string; t:number; data:{ phase:"exit"; code:number } }
    | { type:"state"; runId:string; t:number; data:{ phase:"blocked"; reason:string; deps?:string[] } };
  type LineEvent =
    | { type:"stdout"|"stderr"|"jsonl"; runId:string; t:number; data:{ line:string } };
  ```

---

## 互換と移行

* 旧 **assign** コマンドは非推奨。2モード化により、チェックリストとマニフェストを中心に運用します。
  互換が必要な場合は、plan-dir を出力先として活用し、将来的に完全移行します。

---

## エラーハンドリング（要点）

* `codex` 非検出 / 非対応: 明確なメッセージ（`--force-schema` 等は将来オプション）
* スキーマ不整合: Ajv で詳細メッセージ
* CODEX_HOME 競合: エラー / `--auto-isolate` の案内
* ファイル欠落（manifest / checklists）: 欠落ファイル名と復旧手順を提示

---

## 開発/テスト（TDD 指針）

* **plan.checklists.test**: チェックリストと manifest の生成を検証
* **run.manifest.e2e.test**: manifest 駆動で N 並列実行し、`events.ndjson` を検証
* **tail.latest.test**: デフォルトで最新ランを追えること
* パフォーマンス: 大量ログ耐性（今後拡張）

---

## 例（最短）

```bash
# 1) プラン
splitshot plan --objective README.md --workers 3

# 2) 実行（最新の plan-dir を自動検出）
splitshot run

# ログ（stdout と jsonl のみ表示）
splitshot tail --type stdout,jsonl
```
=== END FILE: docs/spec.md ===

=== BEGIN FILE: docs/todo.md ===
以下は　**2モード仕様**に沿って、現行コードからの移行を前提にした **TDD用TODOチェックリスト**です。
各項目は **RED（テスト追加）→ GREEN（実装）→ REFACTOR（整理）** の順で進められる粒度に分けています。
※後方互換は不要とします（旧 `assign` は廃止でOK）。

---

# SplitShot 2モード化：TDD TODOチェックリスト

## 0. 下準備（共通ユーティリティ）

* [ ] **RED**: `tests/helpers/tmp.ts` を用意し、一時ディレクトリ作成/削除のヘルパを追加

  * 期待: `mkTmpWork("splitshot-")` が空ディレクトリを返す
* [ ] **GREEN**: 実装（`tests/helpers/tmp.ts`）
* [ ] **REFACTOR**: 既存E2Eテストの一時ディレクトリ生成をこのヘルパに置換

---

## 1. プランフェーズ：チェックリスト & マニフェスト生成

* [ ] **RED**: `tests/plan.checklists.test.ts` 新規

  * `splitshot plan --objective "Hello" --workers 2` を実行
  * 期待:

    * `./.splitshot/plan-<ts>/plan.json` が存在（`plan.schema.json` に合致）
    * `./.splitshot/plan-<ts>/plan.prompt.txt` が存在
    * `./.splitshot/plan-<ts>/checklists/worker-01.md`, `worker-02.md` が存在
    * `./.splitshot/plan-<ts>/manifest.json` に `version:1`, `workers.length===2`、`checklist` パスが相対で入っている
* [ ] **GREEN**: `src/cli/plan.ts` を拡張

  * 出力基底：`./.splitshot/plan-<timestamp>/`
  * 既存の Plan 生成・Ajv検証は維持
  * 分配ロジック：タスク（トポロジー順）を `workers` 本にラウンドロビンで割当
  * Markdown生成（各ワーカー）：見出し/Context/Tasks（チェックボックス）/Notes
  * `manifest.json` 生成：`{version:1, objective, createdAt, workers:[{id:"w01", checklist:"checklists/worker-01.md"}, …]}`
* [ ] **REFACTOR**: Markdownテンプレートを `src/templates/checklist.md.tpl` に切り出し（将来のカスタムに備える）

---

## 2. 旧 assign の廃止

* [ ] **RED**: `tests/assign.*.test.ts` を削除 or skip（互換不要）
* [ ] **GREEN**: `src/cli/index.ts` から `cmdAssign()` の登録削除、`src/cli/assign.ts` を削除
* [ ] **REFACTOR**: `src/core/git.ts` も削除（参照なくなるため）

---

## 3. run：manifest 駆動で並列実行（plan-dir 基準）

* [ ] **RED**: `tests/run.manifest.e2e.test.ts` 新規

  * 前段で作った plan-dir を使う
  * `splitshot run --plan-dir <that>`（`--codex tests/fixtures/codex-runner-stub.js`）
  * 期待:

    * `<plan-dir>/.runs/latest.json` が存在し、`runDir` が指すディレクトリに `events.ndjson`/`run.meta.json`
    * `events.ndjson` に各ワーカー `w01`, `w02` の `state:start` → `state:exit` が出る
    * `run.meta.json` に `{ workers:["w01","w02"], maxParallel:2, codexHomes:{ w01:…, w02:… } }`
* [ ] **GREEN**: `src/cli/run.ts` を改修

  * オプション：`--plan-dir <dir>`（省略時は `./.splitshot/plan-*` の **最新**を自動解決）
  * `manifest.json` を読み、`workers[]` を対象に並列実行
  * 各ワーカー：

    * `prompt` = `checklists/worker-XX.md` を読み込み、Codexへ渡す本文に整形
    * `cwd = <plan-dir>`
    * `env`：

      * `CODEX_HOME = <plan-dir>/.homes/<workerId>`（重複時は `-iso-<uniq>` 付与；`--auto-isolate` 既定ON）
      * `SPLITSHOT_RUN_ID = <workerId>`
      * `SPLITSHOT_CHECKLIST_FILE = <abs>`
  * ログ収集：既存 runner/tailer を流用し `<plan-dir>/.runs/<ts>/events.ndjson` に出力
  * `<plan-dir>/.runs/latest.json` を更新
* [ ] **REFACTOR**: `src/core/runner.ts` の `spawnCodex` 引数を `taskId` ベースから `worker` ベースに名称調整、`CODEX_HOME` 解決・衝突検知を関数化

---

## 4. run：`--codex-bin` の解釈（ネイティブ or .js）

* [ ] **RED**: `tests/run.codex-bin.script.test.ts` 新規

  * `--codex tests/fixtures/codex-runner-stub.js` で起動
  * 期待: Windows/Unixとも `.js` は `process.execPath` 経由で spawn され `start/exit` が出る
* [ ] **GREEN**: `src/core/runner.ts` の spawn 引数構築を修正

  * `"codex"` の場合はそのまま
  * `*.js` の場合は `command = process.execPath`, `args=[<abs js>, ...extra]`
* [ ] **REFACTOR**: 判定ロジックを `src/core/spawnArgs.ts` に切り出し

---

## 5. tail：plan-dir の latest を既定参照

* [ ] **RED**: `tests/tail.latest.test.ts` 新規

  * `splitshot run` 実行後、`splitshot tail --type stdout,jsonl`（引数なし）で最新 run が読める
* [ ] **GREEN**: `src/cli/tail.ts` 改修

  * 既定で `--plan-dir` の `.runs/latest.json` を読む
  * 手動オプション `--events <file>` は温存（テスト支援）
* [ ] **REFACTOR**: 参照解決をユーティリティ化 `src/core/paths.ts`（`resolveLatestPlanDir()`, `resolveLatestRun()`）

---

## 6. 失敗時の blocked（初期版：ワーカー単位）

* [ ] **RED**: `tests/run.propagation.manifest.e2e.test.ts` 新規

  * `SPLITSHOT_FORCE_FAIL_TASK_IDS="w01"` で `w01` を失敗させる
  * 期待:

    * `w01` は `start`→`exit(code!=0)`
    * 未開始ワーカー（例：`w02`）には `state:blocked` が記録され、実行されない
    * いったん走り出したワーカーは最後まで流す（同時開始のものがあればそのまま完走）
    * プロセス終了コードは非0
* [ ] **GREEN**: `src/core/runner.ts`

  * 任意ワーカーの exit 失敗を検知したら、キュー上の未開始ワーカーを `blocked` にしてスキップ
* [ ] **REFACTOR**: blocked の理由文字列を定数化し、テストで厳密一致

---

## 7. JSONL フォローの堅牢化（新規ファイル追従）

* [ ] **RED**: `tests/run.jsonl.follow.test.ts` 新規

  * ラン中に `$CODEX_HOME/sessions/s-*/rollout-2.jsonl` を作成して追記
  * 期待: `events.ndjson` に jsonl ラインがすべて取り込まれる（欠落なし）
* [ ] **GREEN**: `src/core/tailer.ts` 改修

  * 200ms ポーリングで「最新だけ」でなく「未認識ファイル」を検出して tail 追加
* [ ] **REFACTOR**: ウォッチ対象の index を Map で持ち、読み取り位置を保持

---

## 8. 大量ログ耐性（10万行）

* [ ] **RED**: `tests/run.massive-logs.test.ts` 新規

  * スタブが `stdout` 10万行出力
  * 期待: `events.ndjson` の `stdout` 行数が一致し、欠落なし（実測で 100k 以上）
* [ ] **GREEN**: `src/core/eventsWriter.ts` に `cork()/uncork()`（例：200行ごと）・`drain` 待ちを実装
* [ ] **REFACTOR**: バッファ閾値を `RUN_EVENTS_FLUSH_INTERVAL` として定数化

---

## 9. エラーメッセージ整備

* [ ] **RED**: `tests/errors.messages.test.ts` 新規

  * `codex` 未検出、`manifest.json` 欠落、`checklist` 欠落、`plan-dir` 不在
  * 期待: コマンド名・原因・対処の短文が含まれる
* [ ] **GREEN**: `src/cli/plan.ts` / `src/cli/run.ts` / `src/cli/tail.ts` に対処ヒント付きの例外を実装
* [ ] **REFACTOR**: 共通フォーマッタ `formatCliError(cmd, reason, hint)` を `src/core/errors.ts` に用意

---

## 10. ドキュメントとメタ

* [ ] **RED**: `tests/readme.snippets.test.ts` 新規（任意）

  * README 記載の最短手順（2コマンド）が動くかをスモーク
* [ ] **GREEN**: `README.md` / `README.en.md` を 2モード手順に更新済みのまま維持
* [ ] **REFACTOR**: `package.json` の `bin` 名称・`engines`・`scripts` を現状に合わせ調整（`pnpm check`）

---

# 実装対象ファイルサマリ

* 追加:

  * `tests/plan.checklists.test.ts` / `tests/run.manifest.e2e.test.ts` / `tests/tail.latest.test.ts`
  * `tests/run.propagation.manifest.e2e.test.ts` / `tests/run.jsonl.follow.test.ts` / `tests/run.massive-logs.test.ts`
  * `tests/helpers/tmp.ts`
  * `src/core/paths.ts` / `src/core/errors.ts` / `src/core/eventsWriter.ts`（分離する場合）
  * `src/templates/checklist.md.tpl`
* 変更:

  * `src/cli/plan.ts` / `src/cli/run.ts` / `src/cli/tail.ts`
  * `src/core/runner.ts` / `src/core/tailer.ts`
  * `src/cli/index.ts`（コマンド登録の見直し）
* 削除:

  * `src/cli/assign.ts` / `src/core/git.ts`
  * `tests/assign*.test.ts`

---

# テスト観点（抜粋）

* plan 出力の **構造**（チェックリスト/マニフェスト/プロンプト/Plan JSON）
* run 出力の **配置**（`.runs/latest.json` と `events.ndjson` の整合）
* **並列制御**（`maxParallel` 既定＝workers数、`--max-parallel` 指定で上書き）
* **CODEX_HOME 競合**（自動 isolate のサフィックス付与）
* **ログ完全性**（stdout/stderr/jsonl 各行が欠落しない）
* **失敗時の挙動**（未開始ワーカーの `blocked`、プロセス終了コード非0）
* tail の **デフォルト解決**（plan-dir 最新 run を自動参照）

---

このチェックリストに沿って、各 RED→GREEN→REFACTOR を順に進めれば、2モード仕様へ段階的に移行できます。=== END FILE: docs/todo.md ===

=== BEGIN FILE: src/core/git.ts ===
import path from "node:path";

export type WorktreeAddParams = {
    gitRoot: string;       // リポジトリのルート（cwd）
    worktreeDir: string;   // 追加するワークツリーのパス
    branch: string;        // 作る/リセットするブランチ名
    baseRef?: string;      // 付け根（デフォルト HEAD）
    force?: boolean;       // --force を付けるか
    noCheckout?: boolean;  // --no-checkout を付けるか
};

export type WorktreeAddCommand = {
    cmd: string;
    args: string[];
    cwd: string;
};

/**
 * git worktree add の実行コマンドを生成（実行はしない）。
 * 例: git worktree add -B splitshot/t1 <worktreeDir> HEAD
 */
export function buildAddWorktreeCommand(p: WorktreeAddParams): WorktreeAddCommand {
    const args = ["worktree", "add"];
    if (p.force) args.push("--force");
    args.push("-B", p.branch);
    if (p.noCheckout) args.push("--no-checkout");
    args.push(path.resolve(p.worktreeDir), p.baseRef ?? "HEAD");
    return {
        cmd: "git",
        args,
        cwd: path.resolve(p.gitRoot),
    };
}=== END FILE: src/core/git.ts ===

=== BEGIN FILE: src/core/types.ts ===
export type Plan = {
    meta?: { objective?: string; workers?: number };
    tasks: TaskSpec[];
};

export type TaskSpec = {
    id: string;
    title: string;
    summary: string;
    cwd: string;
    prompt: string;
    dependsOn?: string[];
    acceptanceCriteria?: string;
    artifactHints?: string[];
    profile?: { model?: string; approval?: "suggest" | "auto" | "full-auto" };
};

export type Assignment = {
    taskId: string;
    worktreeDir: string;
    codexHome: string;
    profile?: { model?: string; approval?: "suggest" | "auto" | "full-auto" };
};

export type Assignments = {
    planId?: string;
    assignments: Assignment[];
};
=== END FILE: src/core/types.ts ===

=== BEGIN FILE: src/core/codex.ts ===
import { execa } from "execa";
import fs from "fs";
import path from "path";

export type CodexFeatures = { hasOutputSchema: boolean; hasJson: boolean };

export type ExecPlanArgs = {
    bin?: string;
    schemaPath: string;
    prompt: string;
    plannerHome?: string; // CODEX_HOME for planner
    extraArgs?: string[];
    timeoutMs?: number;
};

export async function execCodexWithSchema(a: ExecPlanArgs): Promise<string> {
    const bin = a.bin ?? "codex";
    const env = { ...process.env };
    if (a.plannerHome) {
        fs.mkdirSync(a.plannerHome, { recursive: true });
        env.CODEX_HOME = path.resolve(a.plannerHome);
    }
    const args = [
        "exec",
        "--output-schema", a.schemaPath,
        "--quiet",
        "--json",
        ...(a.extraArgs ?? []),
        "--",
        a.prompt
    ];

    const { stdout } = await execa(bin, args, {
        env,
        timeout: a.timeoutMs ?? 120_000,
    });
    return stdout.trim();
}



async function help(bin: string, args: string[]) {
    try {
        const { stdout, stderr } = await execa(bin, args, { reject: false });
        return (stdout || "") + "\n" + (stderr || "");
    } catch {
        return "";
    }
}

export async function detectCodexFeatures(bin = "codex"): Promise<CodexFeatures> {
    // 3パターンの help を総当り
    const texts = await Promise.all([
        help(bin, ["exec", "--help"]),
        help(bin, ["help", "exec"]),
        help(bin, ["--help"]),
    ]);
    const text = texts.join("\n").toLowerCase();

    // ハイフンの数や空白に頑健な判定
    const hasOutputSchema = /--output\s*-\s*schema|--output-schema/.test(text);
    const hasJson = /\s--json(\s|$)/.test(text) || /print.*jsonl/.test(text);

    return { hasOutputSchema, hasJson };
}
=== END FILE: src/core/codex.ts ===

=== BEGIN FILE: src/core/planner.ts ===
export type PlanInput = {
    objective: string;
    workers?: number;
    avoidPaths?: string[];
    mustPaths?: string[];
    approval?: "suggest" | "auto" | "full-auto";
    model?: string;
    deadline?: string;
    repo?: { root?: string; branch?: string; headSha?: string };
};

export function buildPlannerPrompt(p: PlanInput): string {
    return [
        "You are a senior planning agent. Output STRICT JSON ONLY, complying with the provided JSON Schema. No prose.",
        "",
        "OBJECTIVE:",
        p.objective.trim(),
        "",
        "CONSTRAINTS:",
        `- workers: ${p.workers ?? 3}`,
        `- avoid: ${p.avoidPaths?.join(", ") || "none"}`,
        `- mustTouch: ${p.mustPaths?.join(", ") || "none"}`,
        `- approval: ${p.approval ?? "suggest"}`,
        `- model: ${p.model ?? "default"}`,
        `- deadline: ${p.deadline ?? "n/a"}`,
        "",
        "REPO CONTEXT:",
        `${p.repo?.root ?? ""} / ${p.repo?.branch ?? ""} / ${p.repo?.headSha ?? ""}`,
    ].join("\n");
}
=== END FILE: src/core/planner.ts ===

=== BEGIN FILE: src/core/scheduler.ts ===
import type { TaskSpec } from "./types";

/**
 * 依存関係に基づき、同時実行できるタスク群（バッチ）に分割する。
 * トポロジカル順序。循環があれば例外。
 */
export function buildBatches(tasks: TaskSpec[]): TaskSpec[][] {
    const byId = new Map<string, TaskSpec>(tasks.map(t => [t.id, t]));
    const indeg = new Map<string, number>();
    const adj = new Map<string, Set<string>>();

    // 初期化
    for (const t of tasks) {
        indeg.set(t.id, 0);
        adj.set(t.id, new Set());
    }
    for (const t of tasks) {
        for (const d of t.dependsOn ?? []) {
            if (!byId.has(d)) throw new Error(`dependsOn not found: ${t.id} -> ${d}`);
            indeg.set(t.id, (indeg.get(t.id) ?? 0) + 1);
            adj.get(d)!.add(t.id);
        }
    }

    const layers: TaskSpec[][] = [];
    let ready = tasks.filter(t => (indeg.get(t.id) ?? 0) === 0);

    let visited = 0;
    while (ready.length > 0) {
        layers.push(ready);
        const next: TaskSpec[] = [];
        for (const u of ready) {
            visited++;
            for (const v of adj.get(u.id) ?? []) {
                const deg = (indeg.get(v) ?? 0) - 1;
                indeg.set(v, deg);
                if (deg === 0) next.push(byId.get(v)!);
            }
        }
        ready = next;
    }

    if (visited !== tasks.length) {
        throw new Error("cycle detected in dependsOn");
    }
    return layers;
}
=== END FILE: src/core/scheduler.ts ===

=== BEGIN FILE: src/core/schema.ts ===
import Ajv2020 from "ajv/dist/2020.js";
import addFormats from "ajv-formats";
import fs from "fs";
import type { ValidateFunction, ErrorObject } from "ajv";

const ajv = new Ajv2020({ allErrors: true, strict: false });
addFormats(ajv);

export function loadSchema(schemaPath: string): ValidateFunction {
    const json = JSON.parse(fs.readFileSync(schemaPath, "utf8"));
    // Ajv2020#compile の戻り値を型付け
    return ajv.compile(json) as ValidateFunction;
}

export function assertValid<T>(
    validate: ValidateFunction,
    data: unknown
): asserts data is T {
    const ok = validate(data);
    if (!ok) {
        const msg = (validate.errors ?? [])
            .map((e: ErrorObject) => `${e.instancePath || "/"} ${e.message}`)
            .join("; ");
        const err = new Error(`Schema validation failed: ${msg}`) as Error & {
            errors?: ErrorObject[] | null;
        };
        err.errors = validate.errors ?? null;
        throw err;
    }
}
=== END FILE: src/core/schema.ts ===

=== BEGIN FILE: src/core/runner.ts ===
import fs from "node:fs";
import path from "node:path";
import { spawn } from "node:child_process";
import readline from "node:readline";
import crypto from "node:crypto";
import { buildBatches } from "./scheduler.js";
import type { Assignment, Plan, TaskSpec } from "./types.js";

// ---------- CODEX_HOME 競合検知 ----------
export class DuplicateCodexHomeError extends Error {
  homes: string[];
  constructor(message: string, homes: string[]) {
    super(message);
    this.name = "DuplicateCodexHomeError";
    this.homes = homes;
  }
}

export function ensureUniqueCodexHomes(
  assignments: Assignment[],
  { autoIsolate }: { autoIsolate: boolean }
): { assignments: Assignment[]; mapping: Record<string, string> } {
  const byHome = new Map<string, number[]>();
  assignments.forEach((a, i) => {
    const arr = byHome.get(a.codexHome) ?? [];
    arr.push(i);
    byHome.set(a.codexHome, arr);
  });

  const dups = [...byHome.entries()].filter(([, idxs]) => idxs.length > 1);
  if (dups.length === 0) {
    return {
      assignments: assignments.map((a) => ({ ...a })),
      mapping: Object.fromEntries(assignments.map((a) => [a.taskId, a.codexHome])),
    };
  }
  if (!autoIsolate) {
    const homes = dups.map(([h]) => h);
    throw new DuplicateCodexHomeError(
      `Duplicate CODEX_HOME detected: ${homes.join(
        ", "
      )}. Use --auto-isolate to suffix unique directories.`,
      homes
    );
  }
  const cloned = assignments.map((a) => ({ ...a }));
  for (const [, idxs] of dups) {
    for (let j = 1; j < idxs.length; j++) {
      const i = idxs[j];
      const short = crypto.randomUUID().slice(0, 6);
      cloned[i].codexHome = `${cloned[i].codexHome}-iso-${short}`;
    }
  }
  return {
    assignments: cloned,
    mapping: Object.fromEntries(cloned.map((a) => [a.taskId, a.codexHome])),
  };
}


// ---------- events.ndjson ライター ----------
type StateEventData =
  | { phase: "start" }
  | { phase: "exit"; code: number }
  | { phase: "blocked"; reason: "dependency_failed" | string; deps?: string[] };
type LineEventData = { line: string };
type StateEvent = { t: number; type: "state"; runId: string; data: StateEventData };
type LineEvent = {
  t: number;
  type: "stdout" | "stderr" | "jsonl";
  runId: string;
  data: LineEventData;
};
type EventRecord = StateEvent | LineEvent;

function createEventsWriter(filepath: string) {
  fs.mkdirSync(path.dirname(filepath), { recursive: true });
  const ws = fs.createWriteStream(filepath, { flags: "a" });
  let queued = 0;
  return {
    write(obj: EventRecord) {
      // 行バッファ詰まり対策で軽くcork/uncork
      if (++queued % 200 === 0) ws.cork();
      ws.write(JSON.stringify(obj) + "\n");
      if (queued % 200 === 0) process.nextTick(() => ws.uncork());
    },
    async close() {
      await new Promise<void>((r) => ws.end(r));
    },
  };
}

// ---------- rollout-*.jsonl フォロワ ----------
class JsonlFollower {
  private timer?: NodeJS.Timeout;
  private positions = new Map<string, number>();
  private stopped = false;
  constructor(
    private sessionsDir: string,
    private onLine: (line: string) => void,
    private intervalMs = 200
  ) { }

  start() {
    const tick = () => {
      if (this.stopped) return;
      try {
        if (fs.existsSync(this.sessionsDir)) {
          const stack = this.listJsonl(this.sessionsDir);
          for (const fp of stack) this.drain(fp);
        }
      } catch {
        // noop
      }
      this.timer = setTimeout(tick, this.intervalMs);
    };
    tick();
  }

  stop() {
    this.stopped = true;
    if (this.timer) clearTimeout(this.timer);
  }

  private listJsonl(dir: string): string[] {
    const out: string[] = [];
    for (const ent of safeReaddir(dir)) {
      const p = path.join(dir, ent);
      const st = safeStat(p);
      if (st?.isDirectory()) out.push(...this.listJsonl(p));
      else if (/rollout-.*\.jsonl$/.test(ent)) out.push(p);
    }
    return out.sort();
  }

  private drain(fp: string) {
    const pos = this.positions.get(fp) ?? 0;
    const st = safeStat(fp);
    if (!st) return;
    if (st.size < pos) {
      // ローテーション/truncate
      this.positions.set(fp, 0);
      return;
    }
    if (st.size === pos) return;
    const fd = fs.openSync(fp, "r");
    try {
      const len = st.size - pos;
      const buf = Buffer.allocUnsafe(len);
      fs.readSync(fd, buf, 0, len, pos);
      this.positions.set(fp, st.size);
      const text = buf.toString("utf8");
      for (const line of text.split(/\r?\n/)) {
        if (!line.trim()) continue;
        this.onLine(line);
      }
    } finally {
      fs.closeSync(fd);
    }
  }
}

function safeReaddir(dir: string): string[] {
  try {
    return fs.readdirSync(dir);
  } catch {
    return [];
  }
}
function safeStat(p: string) {
  try {
    return fs.statSync(p);
  } catch {
    return undefined;
  }
}

// ---------- ランナ本体 ----------
type RunAllOpts = {
  plan: Plan;
  assignments: Assignment[];
  maxParallel: number;
  codexCmd?: string;
  codexArgs?: string[];
  runDir: string;
};

export async function runAll(opts: RunAllOpts): Promise<number> {
  const { plan, runDir } = opts;
  const events = createEventsWriter(path.join(runDir, "events.ndjson"));
  const batches = buildBatches(plan.tasks);
  const asnById = new Map<string, Assignment>(
    opts.assignments.map((a) => [a.taskId, a])
  );
  const status = new Map<string, "pending" | "running" | "success" | "failed" | "blocked">();
  plan.tasks.forEach((t) => status.set(t.id, "pending"));

  let anyFailed = false;

  for (const layer of batches) {
    const runnable: TaskSpec[] = [];
    for (const t of layer) {
      const deps = t.dependsOn ?? [];
      const failedDeps = deps.filter((d) => status.get(d) === "failed");
      if (failedDeps.length > 0) {
        status.set(t.id, "blocked");
        events.write({
          t: Date.now(),
          type: "state",
          runId: t.id,
          data: { phase: "blocked", reason: "dependency_failed", deps: failedDeps },
        });
      } else {
        runnable.push(t);
      }
    }

    await runWithLimit(
      opts.maxParallel,
      runnable.map((t) => async () => {
        const a = asnById.get(t.id)!;
        // 必要なディレクトリを事前に作成
        fs.mkdirSync(a.worktreeDir, { recursive: true });
        fs.mkdirSync(a.codexHome, { recursive: true });
        status.set(t.id, "running");
        events.write({ t: Date.now(), type: "state", runId: t.id, data: { phase: "start" } });

        // rollout フォロー開始
        const follower = new JsonlFollower(
          path.join(a.codexHome, "sessions"),
          (line) => events.write({ t: Date.now(), type: "jsonl", runId: t.id, data: { line } })
        );
        follower.start();

        const code = await spawnCodex(t.id, a, opts.codexCmd, opts.codexArgs, runDir, (kind, line) =>
          events.write({ t: Date.now(), type: kind, runId: t.id, data: { line } })
        );

        // 少し待ってから follower 停止（最後の追記を拾う）
        await new Promise((r) => setTimeout(r, 200));
        follower.stop();

        events.write({
          t: Date.now(),
          type: "state",
          runId: t.id,
          data: { phase: "exit", code },
        });

        if (code === 0) status.set(t.id, "success");
        else {
          status.set(t.id, "failed");
          anyFailed = true;
        }
      })
    );
  }

  await events.close();
  return anyFailed ? 1 : 0;
}

async function runWithLimit(n: number, jobs: Array<() => Promise<void>>) {
  let i = 0;
  let active = 0;
  return new Promise<void>((resolve) => {
    const next = () => {
      if (i === jobs.length && active === 0) return resolve();
      while (active < n && i < jobs.length) {
        const job = jobs[i++];
        active++;
        job()
          .catch(() => {
            // 個別のエラーは呼び出し側で状態管理済み
          })
          .finally(() => {
            active--;
            next();
          });
      }
    };
    next();
  });
}

function buildSpawnArgs(codexCmd?: string, codexArgs?: string[]) {
  const cmd = codexCmd ?? "codex";
  const args = codexArgs ?? [];
  const isJs = cmd.endsWith(".js");
  if (isJs) {
    return { command: process.execPath, args: [cmd, ...args] };
  }
  return { command: cmd, args };
}

async function spawnCodex(
  runId: string,
  a: Assignment,
  codexCmd: string | undefined,
  codexArgs: string[] | undefined,
  runDir: string,
  onLine: (kind: "stdout" | "stderr", line: string) => void
): Promise<number> {
  const { command, args } = buildSpawnArgs(codexCmd, codexArgs);
  const env = { ...process.env, CODEX_HOME: path.resolve(a.codexHome), SPLITSHOT_RUN_ID: runId };
  const child = spawn(command, args, {
    cwd: a.worktreeDir || process.cwd(),
    env,
    stdio: ["ignore", "pipe", "pipe"],
    windowsHide: true,
  });

  const makeRl = (s: NodeJS.ReadableStream) =>
    readline.createInterface({ input: s, crlfDelay: Infinity });

  const outRl = makeRl(child.stdout!);
  const errRl = makeRl(child.stderr!);
  outRl.on("line", (l) => onLine("stdout", l));
  errRl.on("line", (l) => onLine("stderr", l));

  const code = await new Promise<number>((resolve) => {
    child.on("close", (code) => resolve(code ?? 1));
  });
  return code;
}=== END FILE: src/core/runner.ts ===

=== BEGIN FILE: src/cli/run.ts ===
import { Command } from "commander";
import fs from "node:fs";
import path from "node:path";
import type { Assignments, Plan } from "../core/types";
import { ensureUniqueCodexHomes, DuplicateCodexHomeError, runAll } from "../core/runner.js";

function readJson<T>(p: string): T {
    return JSON.parse(fs.readFileSync(path.resolve(p), "utf8")) as T;
}

export function cmdRun() {
    const cmd = new Command("run");
    cmd
        .description("Execute plan tasks with scheduling and tailing Codex outputs")
        .option("--plan <file>", "Plan JSON file")
        .option("--assignments <file>", "Assignments JSON file")
        .option("--max-parallel <n>", "Max parallel tasks", (v) => parseInt(v, 10), 1)
        .option("--codex <path>", "Runner binary or JS stub", "codex-runner")
        .option("--codex-args <args>", "Extra args (space separated)")
        .option("--auto-isolate", "Auto suffix CODEX_HOME conflicts", false)
        .action(async (opts) => {
            if (!opts.plan) throw new Error("--plan is required");
            if (!opts.assignments) throw new Error("--assignments is required");
            const plan = readJson<Plan>(opts.plan);
            const asn = readJson<Assignments>(opts.assignments);
            const asnAbs = path.resolve(opts.assignments);
            const outBase = path.dirname(asnAbs); // ← 出力ベースを assignments のディレクトリに

            let { assignments } = asn;
            let mapping: Record<string, string> = {};
            try {
                const resolved = ensureUniqueCodexHomes(assignments, { autoIsolate: !!opts.autoIsolate });
                assignments = resolved.assignments;
                mapping = resolved.mapping;
            } catch (e) {
                if (e instanceof DuplicateCodexHomeError) {
                    console.error(e.message);
                    process.exit(1);
                    return;
                }
                throw e;
            }

            const root = path.join(outBase, ".codex-parallel"); // ← ここを変更
            const runsBase = path.join(root, "runs");
            fs.mkdirSync(runsBase, { recursive: true });
            const ts = Date.now();
            const runDir = path.join(runsBase, String(ts));
            fs.mkdirSync(runDir, { recursive: true });

            // メタ
            fs.writeFileSync(
                path.join(runDir, "run.meta.json"),
                JSON.stringify(
                    { planId: asn.planId ?? null, codexHomes: mapping, maxParallel: opts.maxParallel },
                    null,
                    2
                )
            );

            const codexArgs = typeof opts.codexArgs === "string" ? opts.codexArgs.split(/\s+/).filter(Boolean) : undefined;
            const code = await runAll({
                plan,
                assignments,
                maxParallel: opts.maxParallel,
                codexCmd: opts.codex,
                codexArgs,
                runDir,
            });

            // latest ポインタ
            fs.writeFileSync(path.join(runsBase, "latest.json"), JSON.stringify({ runDir }, null, 2));

            process.exit(code);
        });

    return cmd;
}=== END FILE: src/cli/run.ts ===

=== BEGIN FILE: src/cli/index.ts ===
import { Command } from "commander";
import { version, description, name } from "../../package.json";
import { cmdPlan } from "./plan.js";
import { cmdAssign } from "./assign.js";   // ← 追加
import { cmdRun } from "./run.js";
import { cmdTail } from "./tail.js";


const program = new Command();

program
    .name(name || "splitshot")
    .description(description || "Parallel Codex planner & runner (CLI MVP)")
    .version(version);

program.addCommand(cmdPlan());
program.addCommand(cmdAssign());
program.addCommand(cmdRun());
program.addCommand(cmdTail());

program.parseAsync().catch((err) => {
    console.error(err instanceof Error ? err.message : String(err));
    process.exit(1);
});

=== END FILE: src/cli/index.ts ===

=== BEGIN FILE: src/cli/tail.ts ===
import { Command } from "commander";
import fs from "node:fs";
import path from "node:path";

type TailOpts = {
    run?: string;               // runId or "all"
    type?: string;              // csv: stdout,stderr,jsonl,state
    events?: string;            // (test用) events.ndjson を直接指定
    duration?: number;          // フォロー時間(ms)。未指定なら非フォローで即終了
    interval?: number;          // ポーリング間隔(ms)
};

function resolveEventsFile(opts: TailOpts, cwd: string): string {
    if (opts.events) return path.resolve(cwd, opts.events);
    const latest = path.resolve(cwd, ".codex-parallel", "runs", "latest.json");
    if (!fs.existsSync(latest)) {
        throw new Error(`latest.json not found at ${latest}. Provide --events <file> or run from the run base dir.`);
    }
    const { runDir } = JSON.parse(fs.readFileSync(latest, "utf8"));
    const ev = path.join(runDir, "events.ndjson");
    if (!fs.existsSync(ev)) {
        throw new Error(`events.ndjson not found at ${ev}`);
    }
    return ev;
}

function parseTypes(v?: string): Set<string> | null {
    if (!v) return null;
    const s = new Set<string>();
    for (const t of v.split(",").map((x) => x.trim()).filter(Boolean)) s.add(t);
    return s;
}

function matches(line: string, run: string | undefined, types: Set<string> | null): boolean {
    try {
        const obj = JSON.parse(line);
        if (run && run !== "all" && obj.runId !== run) return false;
        if (types && !types.has(obj.type)) return false;
        return true;
    } catch {
        return false;
    }
}

async function tailOnce(evFile: string, run: string | undefined, types: Set<string> | null): Promise<string[]> {
    if (!fs.existsSync(evFile)) return [];
    const text = fs.readFileSync(evFile, "utf8");
    const out: string[] = [];
    for (const ln of text.split(/\r?\n/)) {
        if (!ln.trim()) continue;
        if (matches(ln, run, types)) out.push(ln);
    }
    return out;
}

async function tailFollow(evFile: string, run: string | undefined, types: Set<string> | null, durationMs: number, intervalMs: number): Promise<string[]> {
    let pos = 0;
    const lines: string[] = [];
    const start = Date.now();

    // まずは既存分を読む
    if (fs.existsSync(evFile)) {
        const st = fs.statSync(evFile);
        const buf = fs.readFileSync(evFile, "utf8");
        pos = st.size;
        for (const ln of buf.split(/\r?\n/)) {
            if (!ln.trim()) continue;
            if (matches(ln, run, types)) lines.push(ln);
        }
    }

    while (Date.now() - start < durationMs) {
        await new Promise((r) => setTimeout(r, intervalMs));
        if (!fs.existsSync(evFile)) continue;
        const st = fs.statSync(evFile);
        if (st.size <= pos) continue;
        const fd = fs.openSync(evFile, "r");
        try {
            const len = st.size - pos;
            const buf = Buffer.allocUnsafe(len);
            fs.readSync(fd, buf, 0, len, pos);
            pos = st.size;
            const text = buf.toString("utf8");
            for (const ln of text.split(/\r?\n/)) {
                if (!ln.trim()) continue;
                if (matches(ln, run, types)) lines.push(ln);
            }
        } finally {
            fs.closeSync(fd);
        }
    }
    return lines;
}

export function cmdTail() {
    const cmd = new Command("tail");
    cmd
        .description("Follow events.ndjson and filter by run/type")
        .option("--run <id|all>", "Run ID to filter (default: all)", "all")
        .option("--type <csv>", "Filter types: stdout,stderr,jsonl,state")
        // テスト補助: 直接 events.ndjson を指定できるように
        .option("--events <file>", "Path to events.ndjson (otherwise uses ./.codex-parallel/runs/latest.json)")
        .option("--duration <ms>", "Follow duration milliseconds (if omitted, just prints current contents and exit)", (v) => parseInt(v, 10), undefined)
        .option("--interval <ms>", "Polling interval milliseconds", (v) => parseInt(v, 10), 100)
        .action(async (opts: TailOpts) => {
            const cwd = process.cwd();
            const evFile = resolveEventsFile(opts, cwd);
            const types = parseTypes(opts.type);
            const run = opts.run;

            try {
                let outLines: string[] = [];
                if (typeof opts.duration === "number" && Number.isFinite(opts.duration)) {
                    outLines = await tailFollow(evFile, run, types, opts.duration!, opts.interval ?? 100);
                } else {
                    outLines = await tailOnce(evFile, run, types);
                }
                if (outLines.length) process.stdout.write(outLines.join("\n") + "\n");
                process.exit(0);
            } catch (e) {
                console.error(e instanceof Error ? e.message : String(e));
                process.exit(1);
            }
        });
    return cmd;
}=== END FILE: src/cli/tail.ts ===

=== BEGIN FILE: src/cli/assign.ts ===
import { Command } from "commander";
import fs from "fs";
import path from "path";
import type { Plan, Assignments, Assignment } from "../core/types";
import { buildAddWorktreeCommand, type WorktreeAddCommand } from "../core/git.js";



function parseMap(map?: string): Record<string, string> {
    if (!map) return {};
    const obj: Record<string, string> = {};
    for (const pair of map.split(",").map(s => s.trim()).filter(Boolean)) {
        const [k, v] = pair.split("=");
        if (!k || !v) throw new Error(`invalid map entry: ${pair}`);
        obj[k] = v;
    }
    return obj;
}

function renderTemplate(tpl: string, vars: Record<string, string>) {
    return tpl
        .replaceAll("<taskId>", vars.taskId ?? "")
        .replaceAll("<worktreeDir>", vars.worktreeDir ?? "");
}

export function cmdAssign() {
    const cmd = new Command("assign");
    cmd
        .description("Create assignments from a plan.json and mapping")
        .option("--plan <file>", "Plan JSON file")
        .option("--map <pairs>", "Mapping like t1=../wt1,t2=../wt2")
        .option("--codex-home-template <tpl>", "Template for CODEX_HOME (use <worktreeDir>,<taskId>)",
            "<worktreeDir>/.codex-home-<taskId>")
        .option("--worktree-root <dir>", "Base directory to create worktrees under")
        .option("--auto-worktree", "Emit git worktree add commands for each assignment", false)
        .option("--branch-prefix <prefix>", "Branch prefix for worktrees", "splitshot/")
        .action(async (opts) => {
            if (!opts.plan) throw new Error("--plan is required");
            const planPath = path.resolve(opts.plan);
            const plan = JSON.parse(fs.readFileSync(planPath, "utf8")) as Plan;

            const m = parseMap(opts.map);
            const asg: Assignments = { assignments: [] };
            const gitCmds: WorktreeAddCommand[] = [];

            for (const t of plan.tasks) {
                // worktreeDir は map を最優先、なければ --worktree-root/<taskId>
                let worktreeDir = m[t.id];
                if (!worktreeDir && opts.worktreeRoot) {
                    worktreeDir = path.resolve(String(opts.worktreeRoot), t.id);
                }
                if (!worktreeDir) throw new Error(`no mapping for taskId=${t.id} (provide --map or --worktree-root)`);
                const codexHome = renderTemplate(opts.codexHomeTemplate, { taskId: t.id, worktreeDir });
                const a: Assignment = {
                    taskId: t.id,
                    worktreeDir,
                    codexHome,
                    profile: t.profile,
                };
                asg.assignments.push(a);
                if (opts.autoWorktree) {
                    const branch = String(opts.branchPrefix ?? "splitshot/") + t.id;
                    const cmd = buildAddWorktreeCommand({
                        gitRoot: process.cwd(),
                        worktreeDir,
                        branch,
                        baseRef: "HEAD",
                        force: false,
                        noCheckout: false,
                    });
                    gitCmds.push(cmd);
                }
            }

            // 保存
            const outDir = path.resolve(".codex-parallel");
            fs.mkdirSync(outDir, { recursive: true });
            const fp = path.join(outDir, `assignments-${Date.now()}.json`);
            fs.writeFileSync(fp, JSON.stringify(asg, null, 2));

            // 画面出力には git コマンドも含める（テスト/可視化用）
            const out: Assignments & { git?: { worktreeAdd: WorktreeAddCommand[] } } = { ...asg };
            if (opts.autoWorktree) out.git = { worktreeAdd: gitCmds };
            process.stdout.write(JSON.stringify(out, null, 2) + "\n");
        });

    return cmd;
}
=== END FILE: src/cli/assign.ts ===

=== BEGIN FILE: src/cli/plan.ts ===
// src/cli/plan.ts
// Generate a parallel task plan via Codex (--output-schema) and print validated JSON

import { Command } from "commander";
import fs from "fs";
import path from "path";
import { detectCodexFeatures, execCodexWithSchema } from "../core/codex";
import { loadSchema, assertValid } from "../core/schema";
import { buildPlannerPrompt } from "../core/planner";
import type { Plan } from "../core/types";

async function readMaybeFile(v?: string): Promise<string | undefined> {
    if (!v) return;
    const p = path.resolve(String(v));
    if (fs.existsSync(p) && fs.statSync(p).isFile()) return fs.readFileSync(p, "utf8");
    return v;
}

export function cmdPlan() {
    const cmd = new Command("plan");
    cmd
        .description("Generate parallel task plan via Codex --output-schema")
        .option("--objective <fileOrText>", "Objective file path or raw text")
        .option("--workers <n>", "Workers hint", (v) => parseInt(v, 10), 3)
        .option("--avoid <globs>", "Comma separated globs to avoid (e.g. infra/**,docs/**)")
        .option("--must <globs>", "Comma separated globs to prioritize")
        .option("--approval <mode>", "suggest|auto|full-auto", "suggest")
        .option("--model <name>", "Codex model name")
        .option("--planner-home <dir>", "CODEX_HOME for the planner run")
        .option("--codex-bin <path>", "codex binary path", "codex")
        .option("--timeout <ms>", "execution timeout ms", (v) => parseInt(v, 10), 120000)
        .option(
            "--force-schema",
            "Skip feature detection and use --output-schema directly",
            false
        )
        .action(async (opts) => {
            // 1) Read objective
            const objective = (await readMaybeFile(opts.objective)) ?? "";
            if (!objective.trim()) {
                throw new Error("objective is required (text or file path)");
            }

            // 2) Detect Codex features unless forced
            const feats = await detectCodexFeatures(opts.codexBin);
            if (!opts.forceSchema && !feats.hasOutputSchema) {
                throw new Error(
                    "codex does not support --output-schema (from help parsing). Use --force-schema to skip detection."
                );
            }

            // 3) Resolve schema & validator
            const schemaPath = path.resolve("src/templates/plan.schema.json");
            if (!fs.existsSync(schemaPath)) {
                throw new Error(`Schema file not found: ${schemaPath}`);
            }
            const validate = loadSchema(schemaPath);

            // 4) Build prompt for the planner
            const prompt = buildPlannerPrompt({
                objective,
                workers: opts.workers,
                avoidPaths: (opts.avoid?.split(",") ?? []).map((s: string) => s.trim()).filter(Boolean),
                mustPaths: (opts.must?.split(",") ?? []).map((s: string) => s.trim()).filter(Boolean),
                approval: opts.approval,
                model: opts.model,
            });

            // 5) Run Codex with structured outputs
            const stdout = await execCodexWithSchema({
                bin: opts.codexBin,
                schemaPath,
                prompt,
                plannerHome: opts.plannerHome ?? path.resolve(".codex-home-planner"),
                timeoutMs: opts.timeout,
            });

            // 6) Parse & validate JSON
            let json: unknown;
            try {
                json = JSON.parse(stdout);
            } catch {
                throw new Error(`Codex did not return valid JSON. Raw output:\n${stdout}`);
            }
            assertValid<Plan>(validate, json);
            const plan = json as Plan;

            // 7) Persist artifacts for reproducibility
            const outDir = path.resolve(".codex-parallel");
            fs.mkdirSync(outDir, { recursive: true });
            const ts = Date.now();
            fs.writeFileSync(
                path.join(outDir, `plan-${ts}.json`),
                JSON.stringify(plan, null, 2),
                "utf8"
            );
            fs.writeFileSync(path.join(outDir, `plan.prompt-${ts}.txt`), prompt, "utf8");

            // 8) Emit to stdout (tooling-friendly)
            process.stdout.write(JSON.stringify(plan, null, 2) + "\n");
        });

    return cmd;
}
=== END FILE: src/cli/plan.ts ===

=== BEGIN FILE: src/templates/plan.schema.json ===
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "title": "ParallelPlan",
    "type": "object",
    "required": [
        "tasks"
    ],
    "properties": {
        "meta": {
            "type": "object",
            "properties": {
                "objective": {
                    "type": "string"
                },
                "workers": {
                    "type": "integer",
                    "minimum": 1
                }
            },
            "additionalProperties": true
        },
        "tasks": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "required": [
                    "id",
                    "title",
                    "summary",
                    "cwd",
                    "prompt"
                ],
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "title": {
                        "type": "string"
                    },
                    "summary": {
                        "type": "string"
                    },
                    "cwd": {
                        "type": "string"
                    },
                    "prompt": {
                        "type": "string"
                    },
                    "dependsOn": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "acceptanceCriteria": {
                        "type": "string"
                    },
                    "artifactHints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "profile": {
                        "type": "object",
                        "properties": {
                            "model": {
                                "type": "string"
                            },
                            "approval": {
                                "type": "string",
                                "enum": [
                                    "suggest",
                                    "auto",
                                    "full-auto"
                                ]
                            }
                        },
                        "additionalProperties": false
                    }
                },
                "additionalProperties": false
            }
        }
    },
    "additionalProperties": false
}=== END FILE: src/templates/plan.schema.json ===

=== BEGIN FILE: tests/run.auto-isolate.e2e.test.ts ===
import { describe, it, expect } from "vitest";
import { spawnSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { tmpdir } from "node:os";

const root = process.cwd();
const cli = path.resolve("dist/cli/index.js");
const plan = path.resolve("tests/fixtures/plan-min.json");
const stub = path.resolve("tests/fixtures/codex-runner-stub.js");

function mkTmp(prefix: string) {
    return fs.mkdtempSync(path.join(tmpdir(), prefix));
}
function readLines(p: string) {
    return fs.readFileSync(p, "utf8").trim().split(/\r?\n/).filter(Boolean);
}

describe("run: CODEX_HOME conflicts", () => {
    it("fails without --auto-isolate", () => {
        const work = mkTmp("splitshot-conf-");
        const shared = path.join(work, ".home-shared");
        const asn = {
            assignments: [
                { taskId: "t1", worktreeDir: path.join(work, "wt1"), codexHome: shared },
                { taskId: "t2", worktreeDir: path.join(work, "wt2"), codexHome: shared },
            ],
        };
        const asnFile = path.join(work, "assign.json");
        fs.writeFileSync(asnFile, JSON.stringify(asn, null, 2));

        const out = spawnSync(process.execPath, [
            cli,
            "run",
            "--plan",
            plan,
            "--assignments",
            asnFile,
            "--codex",
            stub,
            "--max-parallel",
            "2",
        ], { cwd: root });

        expect(out.status).not.toBe(0);
        const err = (out.stderr || Buffer.alloc(0)).toString();
        expect(err).toMatch(/Duplicate CODEX_HOME/i);
    });

    it("succeeds with --auto-isolate and both tasks start", () => {
        const work = mkTmp("splitshot-auto-");
        const shared = path.join(work, ".home-shared");
        const asn = {
            assignments: [
                { taskId: "t1", worktreeDir: path.join(work, "wt1"), codexHome: shared },
                { taskId: "t2", worktreeDir: path.join(work, "wt2"), codexHome: shared },
            ],
        };
        const asnFile = path.join(work, "assign.json");
        fs.writeFileSync(asnFile, JSON.stringify(asn, null, 2));

        const out = spawnSync(process.execPath, [
            cli,
            "run",
            "--plan",
            plan,
            "--assignments",
            asnFile,
            "--codex",
            stub,
            "--max-parallel",
            "2",
            "--auto-isolate",
        ], { cwd: root });

        expect(out.status, String(out.stderr)).toBe(0);

        const latest = JSON.parse(fs.readFileSync(path.join(work, ".codex-parallel", "runs", "latest.json"), "utf8"));
        const lines = readLines(path.join(latest.runDir, "events.ndjson"));
        const starts = lines.map((l) => JSON.parse(l)).filter((e) => e.type === "state" && e.data?.phase === "start").map((e) => e.runId);
        expect(new Set(starts)).toEqual(new Set(["t1", "t2"]));
    });
});
=== END FILE: tests/run.auto-isolate.e2e.test.ts ===

=== BEGIN FILE: tests/plan.test.ts ===
// tests/plan.test.ts
import { execa } from "execa";
import { describe, it, expect } from "vitest";
import path from "node:path";

describe("splitshot plan", () => {
    it("prints Plan JSON", async () => {
        const cliPath = path.resolve("dist/cli/index.js");            // ← ここで定義
        const stub = path.resolve("tests/fixtures/codex-stub.js");    // スタブを使う

        const { stdout } = await execa(process.execPath, [
            cliPath,
            "plan",
            "--objective",
            "Hello",
            "--workers",
            "2",
            "--codex-bin",
            stub,
        ]);

        const json = JSON.parse(stdout);
        expect(Array.isArray(json.tasks)).toBe(true);
        expect(json.tasks.length).toBeGreaterThan(0);
        expect(json.meta?.workers).toBe(2);
    });
});
=== END FILE: tests/plan.test.ts ===

=== BEGIN FILE: tests/tail.test.ts ===
import { describe, it, expect } from "vitest";
import { execa } from "execa";
import fs from "node:fs";
import path from "node:path";
import { tmpdir } from "node:os";

const cli = path.resolve("dist/cli/index.js");

function mkWork(prefix: string) {
    const base = fs.mkdtempSync(path.join(tmpdir(), prefix));
    const runs = path.join(base, ".codex-parallel", "runs");
    const runDir = path.join(runs, String(Date.now()));
    fs.mkdirSync(runDir, { recursive: true });
    // latest.json
    fs.writeFileSync(path.join(runs, "latest.json"), JSON.stringify({ runDir }, null, 2));
    return { base, runDir, events: path.join(runDir, "events.ndjson") };
}

describe("splitshot tail", () => {
    it("filters by --run and --type (no follow)", async () => {
        const { base, events } = mkWork("splitshot-tail-");
        const lines = [
            { t: Date.now(), type: "stdout", runId: "t1", data: { line: "A1" } },
            { t: Date.now(), type: "stderr", runId: "t2", data: { line: "B1" } },
            { t: Date.now(), type: "jsonl", runId: "t1", data: { line: '{"ok":1}' } },
            { t: Date.now(), type: "state", runId: "t1", data: { phase: "start" } },
        ];
        fs.writeFileSync(events, lines.map((o) => JSON.stringify(o)).join("\n") + "\n");

        const { stdout, exitCode } = await execa(process.execPath, [
            cli,
            "tail",
            "--run", "t1",
            "--type", "stdout,jsonl",
            // 明示的に events ファイルを指す（テスト補助オプション）
            "--events", events,
        ], { cwd: base });

        expect(exitCode).toBe(0);
        // t1 の stdout と jsonl は出る
        expect(stdout).toMatch(/"type":"stdout".*"runId":"t1"/s);
        expect(stdout).toMatch(/"type":"jsonl".*"runId":"t1"/s);
        // t2 の stderr は出ない
        expect(stdout).not.toMatch(/"runId":"t2".*"type":"stderr"/s);
        // state はフィルタされている
        expect(stdout).not.toMatch(/"type":"state"/);
    });

    it("follows appended lines within --duration window", async () => {
        const { base, events } = mkWork("splitshot-tail-");
        // 初期1行
        fs.writeFileSync(events, JSON.stringify({ t: Date.now(), type: "stdout", runId: "t1", data: { line: "first" } }) + "\n");

        // tail を起動（200msで自動終了）
        const proc = execa(process.execPath, [
            cli,
            "tail",
            "--run", "t1",
            "--type", "stdout",
            "--events", events,
            "--duration", "300"
        ], { cwd: base });

        // 追記を少し遅らせて書く
        await new Promise((r) => setTimeout(r, 80));
        fs.appendFileSync(events, JSON.stringify({ t: Date.now(), type: "stdout", runId: "t1", data: { line: "second" } }) + "\n");

        const { stdout, exitCode } = await proc;
        expect(exitCode).toBe(0);
        expect(stdout).toMatch(/"line":"first"/);
        expect(stdout).toMatch(/"line":"second"/);
    });
});
=== END FILE: tests/tail.test.ts ===

=== BEGIN FILE: tests/run.propagation.e2e.test.ts ===
import { describe, it, expect } from "vitest";
import { spawnSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { tmpdir } from "node:os";

const root = process.cwd();
const cli = path.resolve("dist/cli/index.js");
const plan = path.resolve("tests/fixtures/plan-min.json");
const stub = path.resolve("tests/fixtures/codex-runner-stub.js");

function mkTmp(prefix: string) {
    return fs.mkdtempSync(path.join(tmpdir(), prefix));
}
function readLines(p: string) {
    return fs.readFileSync(p, "utf8").trim().split(/\r?\n/).filter(Boolean);
}

describe("run: failure propagation", () => {
    it("marks dependent tasks as blocked and exits non-zero", () => {
        const work = mkTmp("splitshot-prop-");
        const asn = {
            assignments: [
                { taskId: "t1", worktreeDir: path.join(work, "wt1"), codexHome: path.join(work, ".home-t1") },
                { taskId: "t2", worktreeDir: path.join(work, "wt2"), codexHome: path.join(work, ".home-t2") }, // dependsOn: t1 (plan-min側)
            ],
        };
        const asnFile = path.join(work, "assign.json");
        fs.writeFileSync(asnFile, JSON.stringify(asn, null, 2));

        const out = spawnSync(process.execPath, [
            cli,
            "run",
            "--plan",
            plan,
            "--assignments",
            asnFile,
            "--codex",
            stub,
            "--max-parallel",
            "1",
        ], {
            cwd: root,
            env: {
                ...process.env,
                SPLITSHOT_FORCE_FAIL_TASK_IDS: "t1",
            },
        });

        expect(out.status).not.toBe(0);

        const latest = JSON.parse(fs.readFileSync(path.join(work, ".codex-parallel", "runs", "latest.json"), "utf8"));
        const evs = readLines(path.join(latest.runDir, "events.ndjson")).map((l) => JSON.parse(l));
        const starts = evs.filter((e) => e.type === "state" && e.data?.phase === "start").map((e) => e.runId);
        expect(starts).toContain("t1");
        expect(starts).not.toContain("t2");

        const blocked = evs.find((e) => e.type === "state" && e.runId === "t2" && e.data?.phase === "blocked");
        expect(blocked?.data?.reason).toBe("dependency_failed");
        expect(blocked?.data?.deps).toContain("t1");
    });
});
=== END FILE: tests/run.propagation.e2e.test.ts ===

=== BEGIN FILE: tests/run.scheduler.test.ts ===
import { describe, it, expect } from "vitest";
import { buildBatches } from "../src/core/scheduler";
import type { TaskSpec } from "../src/core/types";

describe("scheduler.buildBatches", () => {
    it("topologically groups tasks into batches", () => {
        const tasks: TaskSpec[] = [
            { id: "t1", title: "A", summary: "", cwd: ".", prompt: "" },
            { id: "t2", title: "B", summary: "", cwd: ".", prompt: "", dependsOn: ["t1"] },
            { id: "t3", title: "C", summary: "", cwd: ".", prompt: "", dependsOn: ["t1"] },
            { id: "t4", title: "D", summary: "", cwd: ".", prompt: "", dependsOn: ["t2", "t3"] }
        ];

        const layers = buildBatches(tasks);
        // 期待: [ [t1], [t2,t3], [t4] ]
        expect(layers.length).toBe(3);
        expect(layers[0].map(t => t.id)).toEqual(["t1"]);
        expect(new Set(layers[1].map(t => t.id))).toEqual(new Set(["t2", "t3"]));
        expect(layers[2].map(t => t.id)).toEqual(["t4"]);
    });

    it("throws on cycles", () => {
        const tasks: TaskSpec[] = [
            { id: "a", title: "", summary: "", cwd: ".", prompt: "", dependsOn: ["b"] },
            { id: "b", title: "", summary: "", cwd: ".", prompt: "", dependsOn: ["a"] }
        ];
        expect(() => buildBatches(tasks)).toThrow();
    });
});
=== END FILE: tests/run.scheduler.test.ts ===

=== BEGIN FILE: tests/assign.test.ts ===
import { execa } from "execa";
import { describe, it, expect, beforeAll } from "vitest";
import fs from "node:fs";
import path from "node:path";
import type { Assignments, Assignment } from "../src/core/types"; // ← 型を使う

const root = process.cwd();
const cli = path.resolve("dist/cli/index.js");

beforeAll(async () => {
    expect(fs.existsSync(cli)).toBe(true);
});

describe("splitshot assign", () => {
    it("maps tasks to worktrees and emits assignments.json", async () => {
        const planPath = path.resolve("tests/fixtures/plan-min.json");
        const { stdout } = await execa(process.execPath, [
            cli,
            "assign",
            "--plan", planPath,
            "--map", "t1=../wt1,t2=../wt2",
            "--codex-home-template", "<worktreeDir>/.codex-home-<taskId>",
        ]);

        const data: Assignments = JSON.parse(stdout);           // ← 型付け
        expect(Array.isArray(data.assignments)).toBe(true);

        const a1 = data.assignments.find((a: Assignment) => a.taskId === "t1");
        expect(a1).toBeTruthy();
        expect(a1!.worktreeDir.endsWith("../wt1")).toBe(true);
        expect(a1!.codexHome.endsWith("../wt1/.codex-home-t1")).toBe(true);

        const a2 = data.assignments.find((a: Assignment) => a.taskId === "t2");
        expect(a2).toBeTruthy();
        expect(a2!.worktreeDir.endsWith("../wt2")).toBe(true);
        expect(a2!.codexHome.endsWith("../wt2/.codex-home-t2")).toBe(true);

        const files = fs.readdirSync(path.join(root, ".codex-parallel"));
        expect(files.some((f) => f.startsWith("assignments-") && f.endsWith(".json"))).toBe(true);
    });
});
=== END FILE: tests/assign.test.ts ===

=== BEGIN FILE: tests/run.e2e.test.ts ===
import { describe, it, expect } from "vitest";
import { spawnSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { tmpdir } from "node:os";

const root = process.cwd();
const cli = path.resolve("dist/cli/index.js");
const plan = path.resolve("tests/fixtures/plan-min.json");
const stub = path.resolve("tests/fixtures/codex-runner-stub.js");

function mkTmp(prefix: string) {
    const p = fs.mkdtempSync(path.join(tmpdir(), prefix));
    return p;
}
function readLines(p: string) {
    return fs.readFileSync(p, "utf8").trim().split(/\r?\n/).filter(Boolean);
}

describe("run (E2E): dependsOn + maxParallel=1", () => {
    it("respects dependsOn order and emits events.ndjson", () => {
        const work = mkTmp("splitshot-e2e-");
        const asn = {
            assignments: [
                { taskId: "t1", worktreeDir: path.join(work, "wt1"), codexHome: path.join(work, ".home-t1") },
                { taskId: "t2", worktreeDir: path.join(work, "wt2"), codexHome: path.join(work, ".home-t2") },
            ],
        };
        const asnFile = path.join(work, "assignments.json");
        fs.writeFileSync(asnFile, JSON.stringify(asn, null, 2));

        const out = spawnSync(process.execPath, [
            cli,
            "run",
            "--plan",
            plan,
            "--assignments",
            asnFile,
            "--codex",
            stub,
            "--max-parallel",
            "1",
        ], { cwd: root });

        expect(out.status, String(out.stderr)).toBe(0);

        const latest = JSON.parse(
            fs.readFileSync(path.join(work, ".codex-parallel", "runs", "latest.json"), "utf8")
        );
        const ev = readLines(path.join(latest.runDir, "events.ndjson")).map((l) => JSON.parse(l));

        const starts = ev.filter((e) => e.type === "state" && e.data?.phase === "start").map((e) => e.runId);
        // t1 が先、t2 が後
        expect(starts[0]).toBe("t1");
        expect(starts[1]).toBe("t2");
    });
});
=== END FILE: tests/run.e2e.test.ts ===

=== BEGIN FILE: tests/scheduler.test.ts ===
import { describe, it, expect } from "vitest";
import { buildBatches } from "../src/core/scheduler.js";
import type { TaskSpec } from "../src/core/types";

describe("run scheduling with maxParallel (skeleton)", () => {
    it("builds batches in topo order", () => {
        const tasks: TaskSpec[] = [
            { id: "t1", title: "A", summary: "", cwd: ".", prompt: "" },
            { id: "t2", title: "B", summary: "", cwd: ".", prompt: "", dependsOn: ["t1"] },
            { id: "t3", title: "C", summary: "", cwd: ".", prompt: "", dependsOn: ["t1"] },
        ];
        const batches = buildBatches(tasks);
        // 期待: [ [t1], [t2,t3] ]
        expect(batches.length).toBe(2);
        expect(batches[0].map((t) => t.id)).toEqual(["t1"]);
        expect(new Set(batches[1].map((t) => t.id))).toEqual(new Set(["t2", "t3"]));
    });
});
=== END FILE: tests/scheduler.test.ts ===

=== BEGIN FILE: tests/assign.worktree.test.ts ===
import { execa } from "execa";
import { describe, it, expect } from "vitest";
import fs from "node:fs";
import path from "node:path";
import { tmpdir } from "node:os";
import type { Assignments, Assignment } from "../src/core/types";
import type { WorktreeAddCommand } from "../src/core/git";

const cli = path.resolve("dist/cli/index.js");
const plan = path.resolve("tests/fixtures/plan-min.json");

function mkTmp(prefix: string) {
    return fs.mkdtempSync(path.join(tmpdir(), prefix));
}
// 画面出力(JSON)の型：assignments に加えて git.worktreeAdd を持つ場合がある
type AssignOut = Assignments & { git?: { worktreeAdd?: WorktreeAddCommand[] } };

describe("splitshot assign --worktree-root/--auto-worktree/--branch-prefix", () => {
    it("generates worktree paths from --worktree-root and emits git worktree add commands when --auto-worktree", async () => {
        const work = mkTmp("splitshot-assign-wt-");
        const wtRoot = path.join(work, "wts");

        const { stdout, exitCode } = await execa(process.execPath, [
            cli,
            "assign",
            "--plan", plan,
            "--worktree-root", wtRoot,
            "--auto-worktree",
            "--branch-prefix", "splitshot/",
            "--codex-home-template", "<worktreeDir>/.codex-home-<taskId>",
        ]);

        expect(exitCode).toBe(0);
        const out: AssignOut = JSON.parse(stdout);

        // assignments: worktreeDir は <root>/<taskId>
        const a1 = out.assignments.find((a: Assignment) => a.taskId === "t1");
        const a2 = out.assignments.find((a: Assignment) => a.taskId === "t2");
        if (!a1 || !a2) throw new Error("assignments for t1/t2 not found");
        expect(a1.worktreeDir).toBe(path.join(wtRoot, "t1"));
        expect(a2.worktreeDir).toBe(path.join(wtRoot, "t2"));

        // git コマンドが2本出力される
        expect(out.git?.worktreeAdd?.length).toBe(2);

        // そのまま型付きで扱う
        const cmds: WorktreeAddCommand[] = out.git?.worktreeAdd ?? [];

        // 形だけでなく、branch と path が正しいかをチェック
        const c1 = cmds.find((c: WorktreeAddCommand) => c.args.includes(path.join(wtRoot, "t1")));
        const c2 = cmds.find((c: WorktreeAddCommand) => c.args.includes(path.join(wtRoot, "t2")));
        if (!c1 || !c2) throw new Error("generated git worktree add commands not found");

        // git worktree add -B splitshot/<taskId> <path> HEAD
        for (const c of [c1, c2]) {
            expect(c.cmd).toBe("git");
            expect(c.args.slice(0, 2)).toEqual(["worktree", "add"]);
            const hasB = c.args.includes("-B");
            expect(hasB).toBe(true);
            const bIdx = c.args.indexOf("-B");
            expect(c.args[bIdx + 1]).toMatch(/^splitshot\/t[12]$/);
            expect(c.args.at(-1)).toBe("HEAD");
        }
    });

    it("does not emit git commands without --auto-worktree (but still maps worktree paths)", async () => {
        const work = mkTmp("splitshot-assign-wt-");
        const wtRoot = path.join(work, "wts");

        const { stdout, exitCode } = await execa(process.execPath, [
            cli,
            "assign",
            "--plan", plan,
            "--worktree-root", wtRoot,
            "--codex-home-template", "<worktreeDir>/.codex-home-<taskId>",
        ]);

        expect(exitCode).toBe(0);
        const out: AssignOut = JSON.parse(stdout);

        const a1 = out.assignments.find((a: Assignment) => a.taskId === "t1");
        const a2 = out.assignments.find((a: Assignment) => a.taskId === "t2");
        if (!a1 || !a2) throw new Error("assignments for t1/t2 not found");
        expect(a1.worktreeDir).toBe(path.join(wtRoot, "t1"));
        expect(a2.worktreeDir).toBe(path.join(wtRoot, "t2"));
        expect(out.git?.worktreeAdd).toBeUndefined();
    });

    it("respects --map overrides even with --worktree-root", async () => {
        const work = mkTmp("splitshot-assign-wt-");
        const wtRoot = path.join(work, "wts");

        const { stdout, exitCode } = await execa(process.execPath, [
            cli,
            "assign",
            "--plan", plan,
            "--map", `t1=${path.join(wtRoot, "override1")}`,
            "--worktree-root", wtRoot,
            "--auto-worktree",
            "--branch-prefix", "wip/",
            "--codex-home-template", "<worktreeDir>/.codex-home-<taskId>",
        ]);

        expect(exitCode).toBe(0);
        const out: AssignOut = JSON.parse(stdout);

        const a1 = out.assignments.find((a: Assignment) => a.taskId === "t1");
        const a2 = out.assignments.find((a: Assignment) => a.taskId === "t2");
        if (!a1 || !a2) throw new Error("assignments for t1/t2 not found");

        // t1 は map の値を優先
        expect(a1.worktreeDir).toBe(path.join(wtRoot, "override1"));
        // t2 は root からの自動
        expect(a2.worktreeDir).toBe(path.join(wtRoot, "t2"));

        // git コマンドは branch-prefix が wip/
        const c1 = out.git?.worktreeAdd?.find((c: WorktreeAddCommand) =>
            c.args.includes(path.join(wtRoot, "override1"))
        );
        const c2 = out.git?.worktreeAdd?.find((c: WorktreeAddCommand) =>
            c.args.includes(path.join(wtRoot, "t2"))
        );
        if (!c1 || !c2) throw new Error("generated git worktree add commands not found");
        const bIdx1 = c1.args.indexOf("-B");
        const bIdx2 = c2.args.indexOf("-B");
        expect(c1.args[bIdx1 + 1]).toBe("wip/t1");
        expect(c2.args[bIdx2 + 1]).toBe("wip/t2");
    });
});=== END FILE: tests/assign.worktree.test.ts ===

=== BEGIN FILE: tests/fixtures/codex-stub.js ===
#!/usr/bin/env node
// 超ミニmal Codexスタブ：--help でフラグを見せ、execでPlan JSONを返す
const args = process.argv.slice(2);

// help: 機能検出用に --output-schema / --json を含めて出力
if (args.includes("--help")) {
  console.log(`
Usage: codex exec [options] -- <prompt>
Options:
  --output-schema <file>
  --json
  --quiet
`);
  process.exit(0);
}

// exec: 構造化JSONを返す
if (args[0] === "exec") {
  // 実際には schema を見ないで固定JSONを返すだけでOK
  const plan = {
    meta: { objective: "stub", workers: 2 },
    tasks: [
      { id: "t1", title: "bootstrap", summary: "init", cwd: ".", prompt: "do something" }
    ]
  };
  process.stdout.write(JSON.stringify(plan));
  process.exit(0);
}

console.error("Unknown invocation:", args.join(" "));
process.exit(1);
=== END FILE: tests/fixtures/codex-stub.js ===

=== BEGIN FILE: tests/fixtures/codex-runner-stub.js ===
#!/usr/bin/env node
// ランナー用スタブ：stdout/stderrを出し、CODEX_HOME/sessions に rollout-*.jsonl を生成
import fs from "node:fs";
import path from "node:path";

const runId = process.env.SPLITSHOT_RUN_ID || "unknown";
const home = process.env.CODEX_HOME || process.cwd();
const force = (process.env.SPLITSHOT_FORCE_FAIL_TASK_IDS || "")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean);

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

async function main() {
  process.stdout.write(`[${runId}] hello from stdout 1\n`);
  process.stderr.write(`[${runId}] warn from stderr 1\n`);

  const sess = path.join(home, "sessions", `s-${Date.now()}`);
  fs.mkdirSync(sess, { recursive: true });
  const f1 = path.join(sess, "rollout-1.jsonl");
  fs.writeFileSync(f1, JSON.stringify({ runId, step: 1, msg: "start" }) + "\n");

  await sleep(30);
  fs.appendFileSync(f1, JSON.stringify({ runId, step: 2, msg: "mid" }) + "\n");
  process.stdout.write(`[${runId}] hello from stdout 2\n`);

  // 新しいファイルが「後から」現れるケース
  await sleep(30);
  const f2 = path.join(sess, "rollout-2.jsonl");
  fs.writeFileSync(f2, JSON.stringify({ runId, step: 3, msg: "new-file" }) + "\n");
  process.stderr.write(`[${runId}] warn from stderr 2\n`);

  if (force.includes(runId)) {
    process.stderr.write(`[${runId}] forced failure\n`);
    process.exit(1);
    return;
  }
  process.exit(0);
}

await main();=== END FILE: tests/fixtures/codex-runner-stub.js ===

=== BEGIN FILE: tests/fixtures/plan-min.json ===
{
    "meta": {
        "objective": "stub",
        "workers": 2
    },
    "tasks": [
        {
            "id": "t1",
            "title": "A",
            "summary": "init",
            "cwd": ".",
            "prompt": "do A"
        },
        {
            "id": "t2",
            "title": "B",
            "summary": "work",
            "cwd": ".",
            "prompt": "do B",
            "dependsOn": [
                "t1"
            ]
        }
    ]
}=== END FILE: tests/fixtures/plan-min.json ===

